== Extensions

You can extend the GraphQL schema with custom types, input types, enums, unions, and interfaces, set or override data fetcher and type resolvers, modify already existing interfaces and types.

To extend the Guillotine application you need to create a file named `guillotine.js` in the `src/main/resources/guillotine` folder of your application.

This file must export a `extensions` function with the following structure:

----
exports.extensions = function (graphQL) {
    return {
        inputTypes: {
            // input type definitions ...
        },
        enums: {
            // enum type definitions ...
        },
        interfaces: {
            // interfaces type definitions ...
        },
        unions: {
            // unions type definitions ...
        },
        types: {
            // output types definitions ...
        },
        creationCallbacks: {
            // creation callback definitions ...
        },
        resolvers: {
            // resolver definitions ...
        },
        typeResolvers: {
            // type resolver definitions ...
        }
    }
};
----

You can omit any of the properties, but you must return an object with the same structure. The order of the properties is not important.

The `extensions` function will be called when the application is started.

Now let's see that closer.

=== graphQL argument

This function takes an `graphQL` argument, which is a reference to the GraphQL utility object.
You can use it to use the following scalars, types, type modifiers and functions:

==== Scalars and Types

`GraphQLString`, `GraphQLInt`, `GraphQLID`, `GraphQLBoolean`, `GraphQLFloat`, `Json`, `DateTime`, `Date`, `LocalTime` `LocalDateTime` and `reference` type.

==== Type modifiers

The `list` and `nonNull` type modifiers allow applies additional validation of those values.

==== Functions

`createDataFetcherResult` - allows to return object with `data` which will be as a source for children fields and provide a `localContext` to share unmodifiable data available in a child field using `env.localContext`.

=== inputTypes

This property is used to create custom input types.
It must be an object with the following structure:

----
inputTypes: {
    <InputTypeName>: {
        description: <description>
        fields: {
            <fieldName>: <graphQLType>,
            // the rest of fields ...
        },
    },
    // the rest of input type definitions ...
}
----

For example:

----
inputTypes: {
    CustomInputFilter: {
        description: "Custom Input Filter",
        fields: {
            exact: graphQL.GraphQLString,
            startsWith: graphQL.GraphQLString,
            endsWith: graphQL.GraphQLString,
            contains: graphQL.GraphQLString
        }
    }
}
----

=== enums

This property is used to create custom enums.
It must be an object with the following structure:

----
enums: {
    <EnumTypeName>: {
        description: <description>
        values: {
            <key1>: <value1>,
            <key2>: <value2>,
            // the rest of pairs of key and value ...
        },
    },
    // the rest of enum type definitions ...
}
----

For example:

----
enums: {
    CustomEnum: {
        description: "Custom Enum",
        values: {
            a: "A",
            b: "B",
        }
    }
}
----

=== interfaces

This property is used to create custom interfaces.
It must be an object with the following structure:

----
interfaces: {
    <InterfaceTypeName>: {
        description: <description>
        fields: {
            <fieldName>: {
               type: <graphQLType>,
               args: {
                 <argName>: <graphQLType>,
                 // the rest of arguments ...
               }
            },
            // the rest of field definitions ...
        },
    },
    // the rest of interface definitions ...
}
----

For example:

----
interfaces: {
    CustomInterface: {
        description: "Custom Interface",
        fields: {
            query: {
                type: graphQL.list(graphQL.GraphQLString),
                args: {
                    filter: graphQL.reference('CustomInputFilter')
                }
            }
        },
    }
}
----

=== unions

This property is used to create custom unions.
It must be an object with the following structure:

----
unions: {
    <UnionTypeName>: {
        description: <description>,
        types: [
            <graphQLType>,
            // the rest of types or reference to type ...
        ],
    },
    // the rest union definitions ...
}
----

For example:

----
unions: {
    CustomUnion: {
        description: "Custom Union",
        types: [
            graphQL.reference('GraphQLTypeNameOne'),
            graphQL.reference('GraphQLTypeNameTwo'),
        ]
    }
}
----

=== types

This property is used to create object types. It must be an object with the following structure:

----
types: {
    <GraphQLTypeName>: {
        description: <description>,
        interfaces: [
            <InterfaceGraphQLType>,
            // the rest of interface types...
        ],
        fields: {
            <fieldName>: {
                type: <graphQLType>,
                args: {
                    <argName>: <graphQLType>,
                    // the rest of arguments definitions ...
                }
            },
            ...
        },
    },
    ...
}
----

For example:

----
types: {
    CustomInterfaceImpl: {
        description: 'CustomInterface Implementation',
        interfaces: [graphQL.reference('CustomInterface')],
        fields: {
            query: {
                type: graphQL.list(graphQL.GraphQLString),
                args: {
                    filter: graphQL.reference('CustomInputFilter')
                }
            },
            extraField: {
                type: graphQL.GraphQLString,
            }
        }
    }
}
----

According to GraphQL specification an implementation of an interface must implement all fields of the interface.

==== Creation callbacks

This property is used to create callbacks that will be called during GraphQL schema generation when a specific type or interface is created.

What you must know about creation callbacks:

- Creation callbacks can be defined only for types and interfaces.
- Creation callback allows to add new fields, modify and remove existing fields, modify description and interfaces for type. Rename of fields is not supported.
- Take aware that creation callbacks can be called not in the same order as them are defined in the `creationCallbacks` property.
- Creation callbacks can be defined in the different applications. Therefore, there is a risk to have conflicts which can lead to schema generation errors or query errors. Not recommended to make modification for Content API's fields. But if you have to do it then make sure that it will not to introduce conflicts and side effects. The developer is fully responsible for that.
- If you add or modify some fields to the interface in the creation callback, you must do that for all implementations. Otherwise, you will get an error during schema generation.
- If you modify some field make sure that you implement correct data fetcher in the `resolvers` section. Otherwise, you can get an error during query execution.

This property must be an object with the following structure:

----
creationCallbacks: {
    <GraphQLTypeName>: function (params) {
        // if you want to add new fields
        params.addFields({
            <newFieldName>: {
                type: <GraphQLType>,
                args: {
                    <argName>: <GraphQLType>,
                    // the rest of arguments definitions ...
                },
            },
        });

        // if you want to remove existing fields
        params.removeFields([
             "fieldName 1",
             "filedName 2",
             // the rest of fieldName ...
        ]);

        // If you want to modify existing fields.
        // Take aware that all arguments will be rewritten by new arguments.
        // If type or args are not provided then will be used type and args from original field.
        params.modifyFields({
            <existingFieldName>: {
                type: <GraphQLType>,
                args: {
                    <argName>: <GraphQLType>,
                    // the rest of arguments definitions ...
                },
            },
        });

        // If you want to change description
        params.setDescription("New description");

        // If you want to add or remove some interfaces to object.
        // Take aware that interfaces will be rewritten by new array of interfaces.
        // Also, developer is responseble for implmentation of interface, do not forget to add all required fields.
        params.setInterfaces([
            <GraphQLInterfaceType or GraphQLReferenceType>
        ]);
    },
    // the rest of creation callback definition ...
}
----

For example:

----
creationCallbacks: {
    MyCustomType: function (params) {
        params.addFields({
            extraField: {
                type: graphQL.GraphQLString,
            }
        });

        params.removeFields([
            "fieldToRemove1",
            "fieldToRemove2",
        ]);

        params.modifyFields({
          fieldToModify: {
            type: graphQL.GraphQLString,
          }
        });
    },

}
----

To know how to set or override data fetcher for a field you can refer to the `resolvers` section.

=== resolvers

This property is used to set or override data fetcher for a field. It must be an object with the following structure:

----
resolvers: {
    <GraphQLTypeName>: {
        <fieldName>: function (env) {
            // your code here
        },
        // the rest of field resolvers ...
    },
    // the rest of type resolvers ...
}
----

==== Application context

You can assume that inside resolver function you have access to the application context where extension is defined and can use `app.name` or `app.config` properties. But in the real that will be context for Guillotine application and those properties will return `com.enonic.app.guillotine` and an actual config for Guillotine application.

If you need to have access in the resolver to the application context where extension is defined, then you can store these values outside `exports.extensions`.

For example:

----
const appName = app.name;
const appConfig = app.config;

exports.extensions = function (graphQL) {
    return {
        ...
        resolvers: {
            MyCustomType: {
                myCustomField: function (env) {
                    // here you can use `appName` and `appConfig`
                }
            }
        },
        ...
   }
}
----

If the configuration of application is changed, then that will trigger restart of the application and Guillotine will update GraphQL schema. In the result you will have actual state of app.config in the resolver.


==== DataFetchingEnvironment

A DataFetchingEnvironment instance (env) is passed to a DataFetcher as an execution context, and it's the place where you can find information to help you resolve a data value given a GraphQL field input.

Guillotine provides the following properties and function in the DataFetchingEnvironment:

- `source` - it is the value of the parent field. For the root query it is equal to `null`.
- `args` - the arguments provided to the field in the GraphQL query.
- `localContext` - a context object that parent fields may have returned. This object  is unmodifiable.

Guillotine Content API supports the following additional properties in `localContext`:

- `\__targetProject` - the current project, can be provided as the `project` argument for `guillotine` field. To read value of this property you can use `env.localContext.__targetProject`.
- `\__targetBranch` - the current branch, can be provided as the `branch` argument for `guillotine` field. To read value of this property you can use `env.localContext.__targetBranch`.
- `\__targetSiteKey` - the key of a site, can be provided as the `siteKey` argument for `guillotine` field. To read value of this property you can use `env.localContext.__targetSiteKey`.

The `localContext` object supports value types such as `string`, `double`, `integer`, `boolean`, and `null`. Keys with a value equal to `null` will be ignored. If you need to provide as a value a complex object, you can use the `JSON.stringify` function to convert it to a string.

==== createDataFetcherResult

Guillotine provides `createDataFetcherResult` function via `graphQL` object. This function will be useful when your `DataFetcher` retrieves data from multiple sources, or you want to pass extra context to lower levels.

The `createDataFetcherResult` function accepts an object with the following properties:

- data - the data to return, must not be `null`. Object must be wrapped by `__.toScriptValue` function.
- localContext - a context object that will be passed to the lower levels. This object is unmodifiable.
- parentLocalContext - a context object that parent fields may have returned.

If `parentLocalContext` is not provided, then `localContext` will override `parentLocalContext`. Otherwise, `localContext` will be merged with `parentLocalContext` and `localContext` will override `parentLocalContext` if they have the same keys.

If `localContext` is not provided, then `parentLocalContext` will be used as `localContext`.

Below you can find an example of how to use `createDataFetcherResult` function:

----
exports.extensions = function (graphQL) {
    return {
        ...
        resolvers: {
            MyCustomType: {
                myCustomField: function (env) {
                    return graphQL.createDataFetcherResult({
                        data: __.toScriptValue({
                           id: "100",
                        }),
                        localContext: {
                            parentId: "101",
                        },
                        parentLocalContext: env.localContext,
                    });
                }
            }
        },
        ...
   }
}
----

=== typeResolvers

This property is used to set or override type resolver for a union or interface. It must be an object with the following structure:

----
typeResolvers: {
    <GraphQLTypeName>: function (obj) {
        // your code here
    },
    // the rest of type resolvers ...
}
----

For example:

----
typeResolvers: {
    CustomInterface: function (obj) {
        return 'CustomInterfaceImpl';
    },
    CustomUnion: function (obj) {
        if (obj.title) {
            return 'GraphQLTypeNameOne';
        }
        return 'GraphQLTypeNameTwo';
    },
}
----

== Example of usage

Let's imagine that we have to extend the GraphQL schema with a new type `GoogleBooks` and add a new field `findBooks` to the `Query` type to be able to find books by query string. To execute requests to Google Books API we will use `lib-http-client` library.

----
dependencies {
    include 'com.enonic.lib:lib-http-client:3.2.2'
}
----

In our application we have to create a new file `src/main/resources/guillotine/guillotine.js` if it absent and add the following content:

----
const httpClient = require('/lib/http-client');

const GOOGLE_BOOKS_API_KEY = app.config.googleBooksApiKey;

exports.extensions = function (graphQL) {
    return {
        types: {
            GoogleBooks: {
                description: 'Google Books Type',
                fields: {
                    id: {
                        type: graphQL.GraphQLString,
                    },
                    title: {
                        type: graphQL.GraphQLString,
                    },
                    authors: {
                        type: graphQL.list(graphQL.GraphQLString),
                    },
                    publisher: {
                        type: graphQL.GraphQLString,
                    },
                    publishedDate: {
                        type: graphQL.GraphQLString,
                    },
                    description: {
                        type: graphQL.GraphQLString,
                    },
                    pageCount: {
                        type: graphQL.GraphQLInt,
                    },
                    language: {
                        type: graphQL.GraphQLString,
                    },
                    averageRating: {
                        type: graphQL.GraphQLFloat,
                    },
                }
            },
        },
        creationCallbacks: {
            Query: function (params) {
                params.addFields({
                    findBooks: {
                        type: graphQL.list(graphQL.reference('GoogleBooks')),
                        args: {
                            queryString: graphQL.GraphQLString,
                        }
                    }
                });
            },
        },
        resolvers: {
            Query: {
                findBooks: function (env) {
                    const response = sendRequestToBooksApi(env.args.queryString);

                    return response.items.map(function (item) {
                        const volumeInfo = item.volumeInfo;

                        return {
                            id: item.id,
                            title: volumeInfo.title,
                            authors: volumeInfo.authors,
                            publisher: volumeInfo.publisher,
                            publishedDate: volumeInfo.publishedDate,
                            description: volumeInfo.description,
                            pageCount: volumeInfo.pageCount,
                            language: volumeInfo.language,
                            averageRating: volumeInfo.averageRating,
                        }
                    });
                }
            }
        },
    }
};

function sendRequestToBooksApi(queryString) {
    const response = httpClient.request({
        url: 'https://www.googleapis.com/books/v1/volumes',
        method: 'GET',
        contentType: 'application/json',
        queryParams: {
            q: queryString,
            key: GOOGLE_BOOKS_API_KEY,
        }
    });
    return JSON.parse(response.body);
}
----

This example is very simple and does not cover all possible cases. For example, it does not handle errors from the Google Books API, does not cache values and, etc. But it shows how to extend the GraphQL schema with a new type and a new field.

You can separate definitions of types, creationCallbacks, resolvers and the rest of options into different files and import them into the `guillotine.js` file, to make your code more readable and maintainable.

